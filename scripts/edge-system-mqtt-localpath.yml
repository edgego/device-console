---
apiVersion: v1
kind: Namespace
metadata:
  name: edge-system
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: edge-role
  labels:
    app: edge-rbac
rules:
  - verbs:
      - get
      - list
      - create
      - delete
      - update
      - watch
    apiGroups:
      - ''
    resources:
      - configmaps
      - services
      - pods
  - verbs:
      - get
      - list
      - create
      - delete
      - update
      - watch
    apiGroups:
      - apps
    resources:
      - deployments
---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: edge-rolebinding
  labels:
    app: edge-rbac
subjects:
  - kind: ServiceAccount
    name: default
    namespace: edge-system
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: edge-role
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: device-dashboard-claim
  namespace: edge-system
spec:
  storageClassName: local-path
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 30M
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: edge-support-scheduler
  namespace: edge-system
data:
  configuration.toml: >
    ScheduleIntervalTime = 500 

    RequireMessageBus = true


    [Writable]

    LogLevel = 'INFO'
        [Writable.InsecureSecrets]
            [Writable.InsecureSecrets.DB]
            path = "redisdb"
                [Writable.InsecureSecrets.DB.Secrets]
                username = ""
                password = ""

    [Service]

    HealthCheckInterval = '10s'

    Host = 'edge-support-scheduler'

    Port = 59861

    ServerBindAddr = '0.0.0.0' # Leave blank so default to Host value unless
    different value is needed.

    StartupMsg = 'This is the Support Scheduler Microservice'

    MaxResultCount = 50000

    MaxRequestSize = 0 # Not curently used. Defines the maximum size of http
    request body in bytes

    RequestTimeout = '5s'

      [Service.CORSConfiguration]

      EnableCORS = false
      CORSAllowCredentials = false
      CORSAllowedOrigin = "http://edge-support-scheduler"
      CORSAllowedMethods = "GET, POST, PUT, PATCH, DELETE"
      CORSAllowedHeaders = "Authorization, Accept, Accept-Language, Content-Language, Content-Type, X-Correlation-ID"
      CORSExposeHeaders = "Cache-Control, Content-Language, Content-Length, Content-Type, Expires, Last-Modified, Pragma, X-Correlation-ID"
      CORSMaxAge = 3600


    [Registry]

    Host = 'localhost'

    Port = 8500

    Type = 'consul'


    [Databases]
      [Databases.Primary]
      Host = 'edge-redis-ha-announce-0'
      Name = 'scheduler'
      Port = 6379
      Timeout = 5000
      Type = 'redisdb'

    [Intervals]
        [Intervals.Midnight]
        Name = 'midnight'
        Start = '20180101T000000'
        Interval = '24h'

    [IntervalActions]
        [IntervalActions.ScrubAged]
        Name = 'scrub-aged-events'
        Host = 'localhost'
        Port = 59880
        Protocol = 'http'
        AdminState='UNLOCKED'
        Method = 'DELETE'
        Target = 'core-data'
        Path = '/api/v2/event/age/604800000000000' # Remove events older than 7 days
        Interval = 'midnight'

    [SecretStore]

    Type = 'vault'

    Protocol = 'http'

    Host = 'localhost'

    Port = 8200

    Path = 'support-scheduler/'

    TokenFile = '/tmp/edgex/secrets/support-scheduler/secrets-token.json'

    RootCaCertPath = ''

    ServerName = ''
      [SecretStore.Authentication]
      AuthType = 'X-Vault-Token'

    [MessageQueue]
      Protocol = "tcp"
      Host = "edge-mqtt-broker"
      Port = 1883
      Type = "mqtt"
      AuthMode = "usernamepassword"  # required for mqtt messagebus (secure or insecure).
      SecretName = "redisdb"
     [MessageQueue.Optional]
      # Default MQTT Specific options that need to be here to enable evnironment variable overrides of them
        ClientId ="support-scheduler"
        Qos = "0" # Quality of Sevice values are 0 (At most once), 1 (At least once) or 2 (Exactly once)
        KeepAlive = "10" # Seconds (must be 2 or greater)
        Retained = "false"
        AutoReconnect = "true"
        ConnectTimeout = "5" # Seconds
        SkipCertVerify = "false"      
        
      [Writable.Telemetry]
        Interval = "0s"
        PublishTopicPrefix  = "edgex/telemetry" # /<service-name>/<metric-name> will be added to this Publish Topic prefix
        [Writable.Telemetry.Metrics] # All service's metric names must be present in this list.
         # Common Security Service Metrics
          SecuritySecretsRequested = false
          SecuritySecretsStored = false
          SecurityConsulTokensRequested = false
          SecurityConsulTokenDuration = false
          [Writable.Telemetry.Tags] # Contains the service level tags to be attached to all the service's metrics
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: edge-core-metadata
  namespace: edge-system
data:
  configuration.toml: >
    RequireMessageBus = true

    [Writable]

     LogLevel = 'DEBUG'
     [Writable.ProfileChange]
      StrictDeviceProfileChanges = false
      StrictDeviceProfileDeletes = false
      [Writable.UoM]
        Validation = true
      [Writable.InsecureSecrets]
        [Writable.InsecureSecrets.DB]
        path = "redisdb"
          [Writable.InsecureSecrets.DB.Secrets]
          username = ""
          password = ""

    [Service]

    HealthCheckInterval = '10s'

    Host = 'edge-core-metadata'

    Port = 59881

    ServerBindAddr = '0.0.0.0' # Leave blank so default to Host value unless
    different value is needed.

    StartupMsg = 'This is the Edge Core Metadata Microservice'

    MaxResultCount = 50000

    MaxRequestSize = 0 # Not curently used. Defines the maximum size of http
    request body in bytes

    RequestTimeout = '5s'

    [Service.CORSConfiguration]
      EnableCORS = false
      CORSAllowCredentials = false
      CORSAllowedOrigin = "http://edge-core-metadata"
      CORSAllowedMethods = "GET, POST, PUT, PATCH, DELETE"
      CORSAllowedHeaders = "Authorization, Accept, Accept-Language, Content-Language, Content-Type, X-Correlation-ID"
      CORSExposeHeaders = "Cache-Control, Content-Language, Content-Length, Content-Type, Expires, Last-Modified, Pragma, X-Correlation-ID"
      CORSMaxAge = 3600

    [UoM]
      UoMFile = "/res/uom/uom.toml"

    [Registry]

    Host = 'localhost'

    Port = 8500

    Type = 'consul'


    [Clients]
      [Clients.support-notifications]
      Protocol = 'http'
      Host = 'edge-support-notifications'
      Port = 59860

      [Clients.core-data]
      Protocol = 'http'
      Host = 'edge-core-data'
      Port = 59880

    [Databases]
      [Databases.Primary]
      Host = 'edge-redis-ha-announce-0'
      Name = 'metadata'
      Password = 'password'
      Username = 'meta'
      Port = 6379
      Timeout = 5000
      Type = 'redisdb'

    [Notifications]

    PostDeviceChanges = true

    Slug = 'device-change-'

    Content = 'Device update: '

    Sender = 'core-metadata'

    Description = 'Metadata device notice'

    Label = 'metadata'


    [SecretStore]

    Type = 'vault'

    Protocol = 'http'

    Host = 'localhost'

    Port = 8200

    Path = 'core-metadata/'

    TokenFile = '/tmp/edgex/secrets/core-metadata/secrets-token.json'

    RootCaCertPath = ''

    ServerName = ''
      [SecretStore.Authentication]
      AuthType = 'X-Vault-Token'
      
    [MessageQueue] 
     Protocol = "tcp"
     Host = "edge-mqtt-broker"
     Port = 1883
     Type = "mqtt"
     AuthMode = "usernamepassword"  # required for mqtt messagebus (secure or insecure).
     SecretName = "redisdb"
     PublishTopicPrefix = "edgex/system-events" 
     [MessageQueue.Optional]
      ClientId ="core-metadata"
      Qos = "0" # 
      KeepAlive = "10" 
      Retained = "false"
      AutoReconnect = "true"
      ConnectTimeout = "5" # Seconds
      SkipCertVerify = "false"

    [Writable.Telemetry]
      Interval = "0s"
      PublishTopicPrefix  = "edgex/telemetry" # /<service-name>/<metric-name> will be added to this Publish Topic prefix
    [Writable.Telemetry.Metrics] 
      SecuritySecretsRequested =false 
      
      SecuritySecretsStored = false 
      
      SecurityConsulTokensRequested = false
      
      SecurityConsulTokenDuration = false 
      
      [Writable.Telemetry.Tags]
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: edge-metadata-uom
  namespace: edge-system
data:
  uom.toml: |
    Source="reference to source for all UoM if not specified below"
    [Units]
      [Units.temperature]
        Source="www.weather.com"
        Values=["C","F","K"]
      [Units.weights]
        Source="www.usa.gov/federal-agencies/weights-and-measures-division"
        Values=["lbs","ounces","kilos","grams"]
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: edge-support-notifications
  namespace: edge-system
data:
  configuration.toml: >-
    RequireMessageBus = true 

    [Writable]

    LogLevel = 'INFO'

    ResendLimit = 3

    ResendInterval = '5s'
      [Writable.InsecureSecrets]
        [Writable.InsecureSecrets.DB]
        path = "redisdb"
          [Writable.InsecureSecrets.DB.Secrets]
          username = ""
          password = ""
        [Writable.InsecureSecrets.SMTP]
        path = "smtp"
          [Writable.InsecureSecrets.SMTP.Secrets]
          username = "username@mail.example.com"
          password = ""

    [Service]

    HealthCheckInterval = '10s'

    Host = 'edge-support-notifications'

    Port = 59860

    ServerBindAddr = '0.0.0.0' # Leave blank so default to Host value unless
    different value is needed.

    StartupMsg = 'This is the Support Notifications Microservice'

    MaxResultCount = 50000

    MaxRequestSize = 0 # Not curently used. Defines the maximum size of http
    request body in bytes

    RequestTimeout = '5s'

    [Service.CORSConfiguration]
      EnableCORS = false
      CORSAllowCredentials = false
      CORSAllowedOrigin = "http://edge-support-notifications"
      CORSAllowedMethods = "GET, POST, PUT, PATCH, DELETE"
      CORSAllowedHeaders = "Authorization, Accept, Accept-Language, Content-Language, Content-Type, X-Correlation-ID"
      CORSExposeHeaders = "Cache-Control, Content-Language, Content-Length, Content-Type, Expires, Last-Modified, Pragma, X-Correlation-ID"
      CORSMaxAge = 3600

    [Registry]

    Host = 'localhost'

    Port = 8500

    Type = 'consul'


    [Databases]
      [Databases.Primary]
      Host = 'edge-redis-ha-announce-0'
      Name = 'notifications'
      Port = 6379
      Timeout = 5000
      Type = 'redisdb'

    [Smtp]
      Host = 'smtp.gmail.com'
      Port = 587
      Sender = 'tian.jacky@gmail.com'
      EnableSelfSignedCert = false
      Subject = 'EdgeX Notification'
      # SecretPath is used to specify the secret path to store the credential(username and password) for connecting the SMTP server
      # User need to store the credential via the /secret API before sending the email notification
      SecretPath = 'smtp'
      # AuthMode is the SMTP authentication mechanism. Currently, 'usernamepassword' is the only AuthMode supported by this service, and the secret keys are 'username' and 'password'.
      AuthMode = 'usernamepassword'


    [SecretStore]

    Type = 'vault'

    Protocol = 'http'

    Host = 'localhost'

    Port = 8200

    Path = 'support-notifications/'

    TokenFile = '/tmp/edgex/secrets/support-notifications/secrets-token.json'

    RootCaCertPath = ''

    ServerName = ''
      [SecretStore.Authentication]
      AuthType = 'X-Vault-Token'
      
    [MessageQueue]
      Protocol = "tcp"
      Host = "edge-nats-server"
      Port = 4222
      Type = "nats-jetstream"
      AuthMode = "usernamepassword"  # required for nats-jetstream messagebus (secure or insecure).
      SecretName = "redisdb"
     [MessageQueue.Optional]
     # Additional Default NATS Specific options that need to be here to enable evnironment variable overrides of them
      Format = "nats"
      RetryOnFailedConnect = "true"
      QueueGroup = ""
      Durable = ""
      AutoProvision = "true"
      Deliver = "new"
      DefaultPubRetryAttempts = "2"
      Subject = "edgex/#" # Required for NATS Jetstram only for stream autoprovsioning     
        
      [Writable.Telemetry]
        Interval = "0s"
        PublishTopicPrefix  = "edgex/telemetry" # /<service-name>/<metric-name> will be added to this Publish Topic prefix
        [Writable.Telemetry.Metrics] # All service's metric names must be present in this list.
         # Common Security Service Metrics
          SecuritySecretsRequested = false
          SecuritySecretsStored = false
          SecurityConsulTokensRequested = false
          SecurityConsulTokenDuration = false
          [Writable.Telemetry.Tags] # Contains the service level tags to be attached to all the service's metrics
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: edge-core-command
  namespace: edge-system
data:
  configuration.toml: >
    [Writable]

    LogLevel = 'DEBUG'
      [Writable.InsecureSecrets]
        [Writable.InsecureSecrets.DB]
        path = "redisdb"
          [Writable.InsecureSecrets.DB.Secrets]
          username = ""
          password = ""

    [Service]

    HealthCheckInterval = '10s'

    Host = 'edge-core-command'

    Port = 59882

    ServerBindAddr = '0.0.0.0' # Leave blank so default to Host value unless
    different value is needed.

    StartupMsg = 'This is the Core Command Microservice'

    MaxResultCount = 50000

    MaxRequestSize = 0 # Not curently used. Defines the maximum size of http
    request body in bytes

    RequestTimeout = '45s'

    [Service.CORSConfiguration]
      EnableCORS = false
      CORSAllowCredentials = false
      CORSAllowedOrigin = "http://edge-core-command"
      CORSAllowedMethods = "GET, POST, PUT, PATCH, DELETE"
      CORSAllowedHeaders = "Authorization, Accept, Accept-Language, Content-Language, Content-Type, X-Correlation-ID"
      CORSExposeHeaders = "Cache-Control, Content-Language, Content-Length, Content-Type, Expires, Last-Modified, Pragma, X-Correlation-ID"
      CORSMaxAge = 3600

    [Registry]

    Host = 'localhost'

    Port = 8500

    Type = 'consul'


    [Clients]
      [Clients.core-metadata]
      Protocol = 'http'
      Host = 'edge-core-metadata'
      Port = 59881

    [Databases]
      [Databases.Primary]
      Host = 'edge-redis-ha-announce-0'
      Name = 'metadata'
      Port = 6379
      Timeout = 5000
      Type = 'redisdb'

    [SecretStore]

    Type = 'vault'

    Protocol = 'http'

    Host = 'localhost'

    Port = 8200

    # Use the core-meta data secrets due to core-command using core-meta-data's
    database for persistance.

    Path = 'core-command/'

    TokenFile = '/tmp/edgex/secrets/core-command/secrets-token.json'

    RootCaCertPath = ''

    ServerName = ''
      [SecretStore.Authentication]
      AuthType = 'X-Vault-Token'
      
    [MessageQueue] 
     Protocol = "tcp"
     Host = "edge-mqtt-broker"
     Port = 1883
     Type = "mqtt"
     AuthMode = "usernamepassword"  # required for mqtt messagebus (secure or insecure).
     SecretName = "redisdb"
     [MessageQueue.Optional]
      ClientId ="edge-core-command"
      Qos = "0" # 
      KeepAlive = "10" 
      Retained = "false"
      AutoReconnect = "true"
      ConnectTimeout = "5" # Seconds
      SkipCertVerify = "false"

    [Writable.Telemetry]
      Interval = "0s"
      PublishTopicPrefix  = "edgex/telemetry" # /<service-name>/<metric-name> will be added to this Publish Topic prefix
    [Writable.Telemetry.Metrics] 
      SecuritySecretsRequested =false 
      
      SecuritySecretsStored = false 
      
      SecurityConsulTokensRequested = false
      
      SecurityConsulTokenDuration = false 
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: device-dashboard
  namespace: edge-system
data:
  configuration.toml: |-
    [Service]
     Host = "device-dashboard"
     Port = 4000
     Labels = []
     OpenMsg = "edge console started"
     StaticResourcesPath = "./www"

     #Using an default memory db automatically if not configed here.
     [Database]
     Host = ""
     Name = ""
     Port = 0
     Username = "su"
     Password = "su"
       [Database.Scheme]
       User = "user"
       
       [MQTTBroker]
          Schema="tcp"
          Host="edge-mqtt-broker"
          Port=1883
          Qos=0
          KeepAlive=3600
          IncomingTopic="DataTopic"
          ResponseTopic="ResponseTopic"
          
       [DeviceServices]
          Names = ["device-modbus","device-opcua","device-mqtt","device-snmp","device-rest","device-rfid-llrp","device-onvif-camera"]
          Images= ["edgego/device-modbus:v2.3.0","edgego/device-opcua:v2.3.0","edgego/device-mqtt:v2.3.0","edgego/device-snmp:v2.3.0","edgego/device-rest:v2.3.0","edgego/device-rfid-llrp:v2.3.0","edgego/device-onvif-camera:v2.3.0"]
      
       [CustomAppServices]
         Names = ["app-face-detect","app-caffe-classifier"]
         Images =["edgego/app-face-detect:v2.3.0","edgego/app-caffe-classifier:v2.2.0"]
        
       [Clients]
         [Clients.CoreData]
         Protocol = 'http'
         Host = 'edge-core-data'
         Port = 59880
         PathPrefix = "/coredata"

         [Clients.Metadata]
         Protocol = 'http'
         Host = 'edge-core-metadata'
         Port = 59881
         PathPrefix = "/metadata"

         [Clients.CoreCommand]
         Protocol = 'http'
         Host = 'edge-core-command'
         Port = 59882
         PathPrefix = "/command"

         [Clients.Notification]
         Protocol = 'http'
         Host = 'edge-support-notifications'
         Port = 59860
         PathPrefix = "/notification"

         [Clients.Scheduler]
         Protocol = 'http'
         Host = 'edge-support-scheduler'
         Port = 59861
         PathPrefix = "/scheduler"

         [Clients.RuleEngine]
         Protocol = 'http'
         Host = 'edge-kuiper'
         Port = 59720
         PathPrefix = "/rule-engine"

         [Clients.AppService]
         Protocol = 'http'
         Host = 'edge-app-rules-engine'
         Port = 59701
         PathPrefix = "/app-service"
         
      [Deploy]
        Namespace = 'edge-system'
        Image = 'edgego/app-service-configurable:v2.3.0'
        Target ='kubernetes'
        Host = ''
        User = ''
        Password = ''
        
       [Registry]
         Host = "edge-core-consul"
         Port = 8500
         Type = "consul"
         ConfigRegistryStem="edgex/appservices/"
         ServiceVersion="2.0"

     [MessageBus]
       Host = "edge-mqtt-broker"
       Port = 1883
       Type = "mqtt"
       [MessageBus.Optional]
         ClientId = "ekuiper" # must be unique name of the service, thus the service key (app-rule-engine, etc) is used
         Qos = 0 # Quality of Sevice values are 0 (At most once), 1 (At least once) or 2 (Exactly once)
         KeepAlive = 500 # Seconds (must be 2 or greater)
         Retained  = false
         #AutoReconnect = true
         #ConnectTimeout = 5 # Seconds
         SkipCertVerify = true
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: edge-core-data
  namespace: edge-system
data:
  configuration.toml: >-
    MaxEventSize = 25000  # Defines the maximum event size in kilobytes

    [Writable]
        PersistData = true 
        LogLevel = 'DEBUG'
        
       [Writable.InsecureSecrets]
          [Writable.InsecureSecrets.DB]
             path = "redisdb"
                [Writable.InsecureSecrets.DB.Secrets]
                username = ""
                password = ""
                
    [Writable.Telemetry]
      Interval = "0s"
      PublishTopicPrefix  = "edgex/telemetry" # /<service-name>/<metric-name> will be added to this Publish Topic prefix
      [Writable.Telemetry.Metrics] # All service's metric names must be present in this list.
       # Core Data Service Metrics
        EventsPersisted = false
        ReadingsPersisted = false
        # Common Security Service Metrics
        SecuritySecretsRequested = false
        SecuritySecretsStored = false
        SecurityConsulTokensRequested = false
        SecurityConsulTokenDuration = false
       [Writable.Telemetry.Tags] # Contains the service level tags to be attached to all the service's metrics
       #    Gateway="my-iot-gateway" # Tag must be added here or via Consul Env Override can only chnage existing value, not added new ones.

    [Service]

    HealthCheckInterval = '10s'

    Host = 'edge-core-data'

    Port = 59880

    ServerBindAddr = '0.0.0.0' # Leave blank so default to Host value unless
    different value is needed.

    StartupMsg = 'Core Data Microservice started'

    MaxResultCount = 50000

    MaxRequestSize = 0 # Not curently used. Defines the maximum size of http
    request body in bytes

    RequestTimeout = '5s'

    [Service.CORSConfiguration]
      EnableCORS = false
      CORSAllowCredentials = false
      CORSAllowedOrigin = "http://edge-core-data"
      CORSAllowedMethods = "GET, POST, PUT, PATCH, DELETE"
      CORSAllowedHeaders = "Authorization, Accept, Accept-Language, Content-Language, Content-Type, X-Correlation-ID"
      CORSExposeHeaders = "Cache-Control, Content-Language, Content-Length, Content-Type, Expires, Last-Modified, Pragma, X-Correlation-ID"
      CORSMaxAge = 3600

    [Registry]

    Host = 'localhost'

    Port = 8500

    Type = 'consul'


    [Clients]
      [Clients.core-metadata]
      Protocol = 'http'
      Host = 'edge-core-metadata'
      Port = 59881

    [Databases]
      [Databases.Primary]
      Host = 'edge-redis-ha-announce-0'
      Name = 'coredata'
      Port = 6379
      Timeout = 5000
      Type = 'redisdb'
      
    [SecretStore]

    Type = 'vault'

    Protocol = 'http'

    Host = 'localhost'

    Port = 8200

    Path = 'core-data/'

    TokenFile = '/tmp/edgex/secrets/core-data/secrets-token.json'

    RootCaCertPath = ''

     ServerName = ''
      [SecretStore.Authentication]
      AuthType = 'X-Vault-Token' 
      
     [MessageQueue]
       Protocol = "tcp"
       Host = "edge-mqtt-broker"
       Port = 1883
       Type = "mqtt"
       AuthMode = "usernamepassword"  # required for redis messagebus (secure or insecure).
       SecretName = "redisdb"
       PublishTopicPrefix = "edgex/events/core" # /<device-profile-name>/<device-name> will be added to this Publish Topic prefix
       SubscribeEnabled = true
       SubscribeTopic = "edgex/events/device/#"  # required for subscribing to Events from MessageBus
      [MessageQueue.Optional]
        ClientId ="core-data"
        Qos =  "0" # Quality of Sevice values are 0 (At most once), 1 (At least once) or 2 (Exactly once)
        KeepAlive = "500" # Seconds (must be 2 or greater)
        Retained = "false"
        AutoReconnect = "true"
        ConnectTimeout = "5" # Seconds
        SkipCertVerify = "false"
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: mosquitto-config
  namespace: edge-system
data:
  mosquitto.conf: >
    # Config file for mosquitto

    #

    # See mosquitto.conf(5) for more information.

    #

    # Default values are shown, uncomment to change.

    #

    # Use the # character to indicate a comment, but only if it is the

    # very first character on the line.


    # =================================================================

    # General configuration

    # =================================================================


    # Use per listener security settings.

    #

    # It is recommended this option be set before any other options.

    #

    # If this option is set to true, then all authentication and access control

    # options are controlled on a per listener basis. The following options are

    # affected:

    #

    # password_file acl_file psk_file auth_plugin auth_opt_* allow_anonymous

    # auto_id_prefix allow_zero_length_clientid

    #

    # Note that if set to true, then a durable client (i.e. with clean session
    set

    # to false) that has disconnected will use the ACL settings defined for the

    # listener that it was most recently connected to.

    #

    # The default behaviour is for this to be set to false, which maintains the

    # setting behaviour from previous versions of mosquitto.

    #per_listener_settings false



    # If a client is subscribed to multiple subscriptions that overlap, e.g.
    foo/#

    # and foo/+/baz , then MQTT expects that when the broker receives a message
    on

    # a topic that matches both subscriptions, such as foo/bar/baz, then the
    client

    # should only receive the message once.

    # Mosquitto keeps track of which clients a message has been sent to in order
    to

    # meet this requirement. The allow_duplicate_messages option allows this

    # behaviour to be disabled, which may be useful if you have a large number
    of

    # clients subscribed to the same set of topics and are very concerned about

    # minimising memory usage.

    # It can be safely set to true if you know in advance that your clients will

    # never have overlapping subscriptions, otherwise your clients must be able
    to

    # correctly deal with duplicate messages even when then have QoS=2.

    #allow_duplicate_messages false


    # This option controls whether a client is allowed to connect with a zero

    # length client id or not. This option only affects clients using MQTT
    v3.1.1

    # and later. If set to false, clients connecting with a zero length client
    id

    # are disconnected. If set to true, clients will be allocated a client id by

    # the broker. This means it is only useful for clients with clean session
    set

    # to true.

    #allow_zero_length_clientid true


    # If allow_zero_length_clientid is true, this option allows you to set a
    prefix

    # to automatically generated client ids to aid visibility in logs.

    # Defaults to 'auto-'

    #auto_id_prefix auto-


    # This option affects the scenario when a client subscribes to a topic that
    has

    # retained messages. It is possible that the client that published the
    retained

    # message to the topic had access at the time they published, but that
    access

    # has been subsequently removed. If check_retain_source is set to true, the

    # default, the source of a retained message will be checked for access
    rights

    # before it is republished. When set to false, no check will be made and the

    # retained message will always be published. This affects all listeners.

    #check_retain_source true


    # QoS 1 and 2 messages will be allowed inflight per client until this limit

    # is exceeded.  Defaults to 0. (No maximum)

    # See also max_inflight_messages

    #max_inflight_bytes 0


    # The maximum number of QoS 1 and 2 messages currently inflight per

    # client.

    # This includes messages that are partway through handshakes and

    # those that are being retried. Defaults to 20. Set to 0 for no

    # maximum. Setting to 1 will guarantee in-order delivery of QoS 1

    # and 2 messages.

    #max_inflight_messages 20


    # For MQTT v5 clients, it is possible to have the server send a "server

    # keepalive" value that will override the keepalive value set by the client.

    # This is intended to be used as a mechanism to say that the server will

    # disconnect the client earlier than it anticipated, and that the client
    should

    # use the new keepalive value. The max_keepalive option allows you to
    specify

    # that clients may only connect with keepalive less than or equal to this

    # value, otherwise they will be sent a server keepalive telling them to use

    # max_keepalive. This only applies to MQTT v5 clients. The maximum value

    # allowable is 65535. Do not set below 10.

    #max_keepalive 65535


    # For MQTT v5 clients, it is possible to have the server send a "maximum
    packet

    # size" value that will instruct the client it will not accept MQTT packets

    # with size greater than max_packet_size bytes. This applies to the full
    MQTT

    # packet, not just the payload. Setting this option to a positive value will

    # set the maximum packet size to that number of bytes. If a client sends a

    # packet which is larger than this value, it will be disconnected. This
    applies

    # to all clients regardless of the protocol version they are using, but
    v3.1.1

    # and earlier clients will of course not have received the maximum packet
    size

    # information. Defaults to no limit. Setting below 20 bytes is forbidden

    # because it is likely to interfere with ordinary client operation, even
    with

    # very small payloads.

    #max_packet_size 0


    # QoS 1 and 2 messages above those currently in-flight will be queued per

    # client until this limit is exceeded.  Defaults to 0. (No maximum)

    # See also max_queued_messages.

    # If both max_queued_messages and max_queued_bytes are specified, packets
    will

    # be queued until the first limit is reached.

    #max_queued_bytes 0


    # The maximum number of QoS 1 and 2 messages to hold in a queue per client

    # above those that are currently in-flight.  Defaults to 100. Set

    # to 0 for no maximum (not recommended).

    # See also queue_qos0_messages.

    # See also max_queued_bytes.

    #max_queued_messages 100

    #

    # This option sets the maximum number of heap memory bytes that the broker
    will

    # allocate, and hence sets a hard limit on memory use by the broker.  Memory

    # requests that exceed this value will be denied. The effect will vary

    # depending on what has been denied. If an incoming message is being
    processed,

    # then the message will be dropped and the publishing client will be

    # disconnected. If an outgoing message is being sent, then the individual

    # message will be dropped and the receiving client will be disconnected.

    # Defaults to no limit.

    #memory_limit 0


    # This option sets the maximum publish payload size that the broker will
    allow.

    # Received messages that exceed this size will not be accepted by the
    broker.

    # The default value is 0, which means that all valid MQTT messages are

    # accepted. MQTT imposes a maximum payload size of 268435455 bytes.

    #message_size_limit 0


    # This option allows persistent clients (those with clean session set to
    false)

    # to be removed if they do not reconnect within a certain time frame.

    #

    # This is a non-standard option in MQTT V3.1 but allowed in MQTT v3.1.1.

    #

    # Badly designed clients may set clean session to false whilst using a
    randomly

    # generated client id. This leads to persistent clients that will never

    # reconnect. This option allows these clients to be removed.

    #

    # The expiration period should be an integer followed by one of h d w m y
    for

    # hour, day, week, month and year respectively. For example

    #

    # persistent_client_expiration 2m

    # persistent_client_expiration 14d

    # persistent_client_expiration 1y

    #

    # The default if not set is to never expire persistent clients.

    #persistent_client_expiration


    # Write process id to a file. Default is a blank string which means

    # a pid file shouldn't be written.

    # This should be set to /var/run/mosquitto.pid if mosquitto is

    # being run automatically on boot with an init script and

    # start-stop-daemon or similar.

    #pid_file


    # Set to true to queue messages with QoS 0 when a persistent client is

    # disconnected. These messages are included in the limit imposed by

    # max_queued_messages and max_queued_bytes

    # Defaults to false.

    # This is a non-standard option for the MQTT v3.1 spec but is allowed in

    # v3.1.1.

    #queue_qos0_messages false


    # Set to false to disable retained message support. If a client publishes a

    # message with the retain bit set, it will be disconnected if this is set to

    # false.

    #retain_available true


    # Disable Nagle's algorithm on client sockets. This has the effect of
    reducing

    # latency of individual messages at the potential cost of increasing the
    number

    # of packets being sent.

    #set_tcp_nodelay false


    # Time in seconds between updates of the $SYS tree.

    # Set to 0 to disable the publishing of the $SYS tree.

    #sys_interval 10


    # The MQTT specification requires that the QoS of a message delivered to a

    # subscriber is never upgraded to match the QoS of the subscription.
    Enabling

    # this option changes this behaviour. If upgrade_outgoing_qos is set true,

    # messages sent to a subscriber will always match the QoS of its
    subscription.

    # This is a non-standard option explicitly disallowed by the spec.

    #upgrade_outgoing_qos false


    # When run as root, drop privileges to this user and its primary

    # group.

    # Set to root to stay as root, but this is not recommended.

    # If run as a non-root user, this setting has no effect.

    # Note that on Windows this has no effect and so mosquitto should

    # be started by the user you wish it to run as.

    #user mosquitto


    # =================================================================

    # Default listener

    # =================================================================


    # IP address/hostname to bind the default listener to. If not

    # given, the default listener will not be bound to a specific

    # address and so will be accessible to all network interfaces.

    # bind_address ip-address/host name

    #bind_address


    # Port to use for the default listener.

    port 1883


    # Bind the listener to a specific interface. This is similar to

    # bind_address above but is useful when an interface has multiple addresses
    or

    # the address may change. It is valid to use this with the bind_address
    option,

    # but take care that the interface you are binding to contains the address
    you

    # are binding to, otherwise you will not be able to connect.

    # Example: bind_interface eth0

    #bind_interface


    # When a listener is using the websockets protocol, it is possible to serve

    # http data as well. Set http_dir to a directory which contains the files
    you

    # wish to serve. If this option is not specified, then no normal http

    # connections will be possible.

    #http_dir


    # The maximum number of client connections to allow. This is

    # a per listener setting.

    # Default is -1, which means unlimited connections.

    # Note that other process limits mean that unlimited connections

    # are not really possible. Typically the default maximum number of

    # connections possible is around 1024.

    #max_connections -1


    # Choose the protocol to use when listening.

    # This can be either mqtt or websockets.

    # Websockets support is currently disabled by default at compile time.

    # Certificate based TLS may be used with websockets, except that

    # only the cafile, certfile, keyfile and ciphers options are supported.

    #protocol mqtt


    # Set use_username_as_clientid to true to replace the clientid that a client

    # connected with with its username. This allows authentication to be tied to

    # the clientid, which means that it is possible to prevent one client

    # disconnecting another by using the same clientid.

    # If a client connects with no username it will be disconnected as not

    # authorised when this option is set to true.

    # Do not use in conjunction with clientid_prefixes.

    # See also use_identity_as_username.

    #use_username_as_clientid


    # -----------------------------------------------------------------

    # Certificate based SSL/TLS support

    # -----------------------------------------------------------------

    # The following options can be used to enable SSL/TLS support for

    # this listener. Note that the recommended port for MQTT over TLS

    # is 8883, but this must be set manually.

    #

    # See also the mosquitto-tls man page.


    # At least one of cafile or capath must be defined. They both

    # define methods of accessing the PEM encoded Certificate

    # Authority certificates that have signed your server certificate

    # and that you wish to trust.

    # cafile defines the path to a file containing the CA certificates.

    # capath defines a directory that will be searched for files

    # containing the CA certificates. For capath to work correctly, the

    # certificate files must have ".crt" as the file ending and you must run

    # "openssl rehash <path to capath>" each time you add/remove a certificate.

    #cafile

    #capath


    # Path to the PEM encoded server certificate.

    #certfile


    # Path to the PEM encoded keyfile.

    #keyfile



    # If you have require_certificate set to true, you can create a certificate

    # revocation list file to revoke access to particular client certificates.
    If

    # you have done this, use crlfile to point to the PEM encoded revocation
    file.

    #crlfile


    # If you wish to control which encryption ciphers are used, use the ciphers

    # option. The list of available ciphers can be obtained using the "openssl

    # ciphers" command and should be provided in the same format as the output
    of

    # that command.

    # If unset defaults to DEFAULT:!aNULL:!eNULL:!LOW:!EXPORT:!SSLv2:@STRENGTH

    #ciphers DEFAULT:!aNULL:!eNULL:!LOW:!EXPORT:!SSLv2:@STRENGTH


    # To allow the use of ephemeral DH key exchange, which provides forward

    # security, the listener must load DH parameters. This can be specified with

    # the dhparamfile option. The dhparamfile can be generated with the command

    # e.g. "openssl dhparam -out dhparam.pem 2048"

    #dhparamfile


    # By default a TLS enabled listener will operate in a similar fashion to a

    # https enabled web server, in that the server has a certificate signed by a
    CA

    # and the client will verify that it is a trusted certificate. The overall
    aim

    # is encryption of the network traffic. By setting require_certificate to
    true,

    # the client must provide a valid certificate in order for the network

    # connection to proceed. This allows access to the broker to be controlled

    # outside of the mechanisms provided by MQTT.

    #require_certificate false


    # This option defines the version of the TLS protocol to use for this
    listener.

    # The default value allows all of v1.3, v1.2 and v1.1. The valid values are

    # tlsv1.3 tlsv1.2 and tlsv1.1.

    #tls_version


    # If require_certificate is true, you may set use_identity_as_username to
    true

    # to use the CN value from the client certificate as a username. If this is

    # true, the password_file option will not be used for this listener.

    # This takes priority over use_subject_as_username.

    # See also use_subject_as_username.

    #use_identity_as_username false


    # If require_certificate is true, you may set use_subject_as_username to
    true

    # to use the complete subject value from the client certificate as a
    username.

    # If this is true, the password_file option will not be used for this
    listener.

    # See also use_identity_as_username

    #use_subject_as_username false


    # -----------------------------------------------------------------

    # Pre-shared-key based SSL/TLS support

    # -----------------------------------------------------------------

    # The following options can be used to enable PSK based SSL/TLS support for

    # this listener. Note that the recommended port for MQTT over TLS is 8883,
    but

    # this must be set manually.

    #

    # See also the mosquitto-tls man page and the "Certificate based SSL/TLS

    # support" section. Only one of certificate or PSK encryption support can be

    # enabled for any listener.


    # The psk_hint option enables pre-shared-key support for this listener and
    also

    # acts as an identifier for this listener. The hint is sent to clients and
    may

    # be used locally to aid authentication. The hint is a free form string that

    # doesn't have much meaning in itself, so feel free to be creative.

    # If this option is provided, see psk_file to define the pre-shared keys to
    be

    # used or create a security plugin to handle them.

    #psk_hint


    # When using PSK, the encryption ciphers used will be chosen from the list
    of

    # available PSK ciphers. If you want to control which ciphers are available,

    # use the "ciphers" option.  The list of available ciphers can be obtained

    # using the "openssl ciphers" command and should be provided in the same
    format

    # as the output of that command.

    #ciphers


    # Set use_identity_as_username to have the psk identity sent by the client
    used

    # as its username. Authentication will be carried out using the PSK rather
    than

    # the MQTT username/password and so password_file will not be used for this

    # listener.

    #use_identity_as_username false



    # =================================================================

    # Extra listeners

    # =================================================================


    # Listen on a port/ip address combination. By using this variable

    # multiple times, mosquitto can listen on more than one port. If

    # this variable is used and neither bind_address nor port given,

    # then the default listener will not be started.

    # The port number to listen on must be given. Optionally, an ip

    # address or host name may be supplied as a second argument. In

    # this case, mosquitto will attempt to bind the listener to that

    # address and so restrict access to the associated network and

    # interface. By default, mosquitto will listen on all interfaces.

    # Note that for a websockets listener it is not possible to bind to a host

    # name.

    # listener port-number [ip address/host name]

    #listener 1883


    # Bind the listener to a specific interface. This is similar to

    # the [ip address/host name] part of the listener definition, but is useful

    # when an interface has multiple addresses or the address may change. It is

    # valid to use this with the [ip address/host name] part of the listener

    # definition, but take care that the interface you are binding to contains
    the

    # address you are binding to, otherwise you will not be able to connect.

    # Only available on Linux and requires elevated privileges.

    #

    # Example: bind_interface eth0

    #bind_interface


    # When a listener is using the websockets protocol, it is possible to serve

    # http data as well. Set http_dir to a directory which contains the files
    you

    # wish to serve. If this option is not specified, then no normal http

    # connections will be possible.

    #http_dir


    # The maximum number of client connections to allow. This is

    # a per listener setting.

    # Default is -1, which means unlimited connections.

    # Note that other process limits mean that unlimited connections

    # are not really possible. Typically the default maximum number of

    # connections possible is around 1024.

    #max_connections -1


    # The listener can be restricted to operating within a topic hierarchy using

    # the mount_point option. This is achieved be prefixing the mount_point
    string

    # to all topics for any clients connected to this listener. This prefixing
    only

    # happens internally to the broker; the client will not see the prefix.

    #mount_point


    # Choose the protocol to use when listening.

    # This can be either mqtt or websockets.

    # Certificate based TLS may be used with websockets, except that only the

    # cafile, certfile, keyfile and ciphers options are supported.

    #protocol mqtt


    # Set use_username_as_clientid to true to replace the clientid that a client

    # connected with with its username. This allows authentication to be tied to

    # the clientid, which means that it is possible to prevent one client

    # disconnecting another by using the same clientid.

    # If a client connects with no username it will be disconnected as not

    # authorised when this option is set to true.

    # Do not use in conjunction with clientid_prefixes.

    # See also use_identity_as_username.

    #use_username_as_clientid


    # Change the websockets headers size. This is a global option, it is not

    # possible to set per listener. This option sets the size of the buffer used
    in

    # the libwebsockets library when reading HTTP headers. If you are passing
    large

    # header data such as cookies then you may need to increase this value. If
    left

    # unset, or set to 0, then the default of 1024 bytes will be used.

    #websockets_headers_size


    # -----------------------------------------------------------------

    # Certificate based SSL/TLS support

    # -----------------------------------------------------------------

    # The following options can be used to enable certificate based SSL/TLS
    support

    # for this listener. Note that the recommended port for MQTT over TLS is
    8883,

    # but this must be set manually.

    #

    # See also the mosquitto-tls man page and the "Pre-shared-key based SSL/TLS

    # support" section. Only one of certificate or PSK encryption support can be

    # enabled for any listener.


    # At least one of cafile or capath must be defined to enable certificate
    based

    # TLS encryption. They both define methods of accessing the PEM encoded

    # Certificate Authority certificates that have signed your server
    certificate

    # and that you wish to trust.

    # cafile defines the path to a file containing the CA certificates.

    # capath defines a directory that will be searched for files

    # containing the CA certificates. For capath to work correctly, the

    # certificate files must have ".crt" as the file ending and you must run

    # "openssl rehash <path to capath>" each time you add/remove a certificate.

    #cafile

    #capath


    # Path to the PEM encoded server certificate.

    #certfile


    # Path to the PEM encoded keyfile.

    #keyfile



    # If you wish to control which encryption ciphers are used, use the ciphers

    # option. The list of available ciphers can be optained using the "openssl

    # ciphers" command and should be provided in the same format as the output
    of

    # that command.

    #ciphers


    # If you have require_certificate set to true, you can create a certificate

    # revocation list file to revoke access to particular client certificates.
    If

    # you have done this, use crlfile to point to the PEM encoded revocation
    file.

    #crlfile


    # To allow the use of ephemeral DH key exchange, which provides forward

    # security, the listener must load DH parameters. This can be specified with

    # the dhparamfile option. The dhparamfile can be generated with the command

    # e.g. "openssl dhparam -out dhparam.pem 2048"

    #dhparamfile


    # By default an TLS enabled listener will operate in a similar fashion to a

    # https enabled web server, in that the server has a certificate signed by a
    CA

    # and the client will verify that it is a trusted certificate. The overall
    aim

    # is encryption of the network traffic. By setting require_certificate to
    true,

    # the client must provide a valid certificate in order for the network

    # connection to proceed. This allows access to the broker to be controlled

    # outside of the mechanisms provided by MQTT.

    #require_certificate false


    # If require_certificate is true, you may set use_identity_as_username to
    true

    # to use the CN value from the client certificate as a username. If this is

    # true, the password_file option will not be used for this listener.

    #use_identity_as_username false


    # -----------------------------------------------------------------

    # Pre-shared-key based SSL/TLS support

    # -----------------------------------------------------------------

    # The following options can be used to enable PSK based SSL/TLS support for

    # this listener. Note that the recommended port for MQTT over TLS is 8883,
    but

    # this must be set manually.

    #

    # See also the mosquitto-tls man page and the "Certificate based SSL/TLS

    # support" section. Only one of certificate or PSK encryption support can be

    # enabled for any listener.


    # The psk_hint option enables pre-shared-key support for this listener and
    also

    # acts as an identifier for this listener. The hint is sent to clients and
    may

    # be used locally to aid authentication. The hint is a free form string that

    # doesn't have much meaning in itself, so feel free to be creative.

    # If this option is provided, see psk_file to define the pre-shared keys to
    be

    # used or create a security plugin to handle them.

    #psk_hint


    # When using PSK, the encryption ciphers used will be chosen from the list
    of

    # available PSK ciphers. If you want to control which ciphers are available,

    # use the "ciphers" option.  The list of available ciphers can be optained

    # using the "openssl ciphers" command and should be provided in the same
    format

    # as the output of that command.

    #ciphers


    # Set use_identity_as_username to have the psk identity sent by the client
    used

    # as its username. Authentication will be carried out using the PSK rather
    than

    # the MQTT username/password and so password_file will not be used for this

    # listener.

    #use_identity_as_username false



    # =================================================================

    # Persistence

    # =================================================================


    # If persistence is enabled, save the in-memory database to disk

    # every autosave_interval seconds. If set to 0, the persistence

    # database will only be written when mosquitto exits. See also

    # autosave_on_changes.

    # Note that writing of the persistence database can be forced by

    # sending mosquitto a SIGUSR1 signal.

    #autosave_interval 1800


    # If true, mosquitto will count the number of subscription changes, retained

    # messages received and queued messages and if the total exceeds

    # autosave_interval then the in-memory database will be saved to disk.

    # If false, mosquitto will save the in-memory database to disk by treating

    # autosave_interval as a time in seconds.

    #autosave_on_changes false


    # Save persistent message data to disk (true/false).

    # This saves information about all messages, including

    # subscriptions, currently in-flight messages and retained

    # messages.

    # retained_persistence is a synonym for this option.

    #persistence false


    # The filename to use for the persistent database, not including

    # the path.

    #persistence_file mosquitto.db


    # Location for persistent database. Must include trailing /

    # Default is an empty string (current directory).

    # Set to e.g. /var/lib/mosquitto/ if running as a proper service on Linux or

    # similar.

    #persistence_location



    # =================================================================

    # Logging

    # =================================================================


    # Places to log to. Use multiple log_dest lines for multiple

    # logging destinations.

    # Possible destinations are: stdout stderr syslog topic file

    #

    # stdout and stderr log to the console on the named output.

    #

    # syslog uses the userspace syslog facility which usually ends up

    # in /var/log/messages or similar.

    #

    # topic logs to the broker topic '$SYS/broker/log/<severity>',

    # where severity is one of D, E, W, N, I, M which are debug, error,

    # warning, notice, information and message. Message type severity is used by

    # the subscribe/unsubscribe log_types and publishes log messages to

    # $SYS/broker/log/M/susbcribe or $SYS/broker/log/M/unsubscribe.

    #

    # The file destination requires an additional parameter which is the file to
    be

    # logged to, e.g. "log_dest file /var/log/mosquitto.log". The file will be

    # closed and reopened when the broker receives a HUP signal. Only a single
    file

    # destination may be configured.

    #

    # Note that if the broker is running as a Windows service it will default to

    # "log_dest none" and neither stdout nor stderr logging is available.

    # Use "log_dest none" if you wish to disable logging.

    #log_dest stderr


    # Types of messages to log. Use multiple log_type lines for logging

    # multiple types of messages.

    # Possible types are: debug, error, warning, notice, information,

    # none, subscribe, unsubscribe, websockets, all.

    # Note that debug type messages are for decoding the incoming/outgoing

    # network packets. They are not logged in "topics".

    #log_type error

    #log_type warning

    #log_type notice

    #log_type information



    # If set to true, client connection and disconnection messages will be
    included

    # in the log.

    #connection_messages true


    # If using syslog logging (not on Windows), messages will be logged to the

    # "daemon" facility by default. Use the log_facility option to choose which
    of

    # local0 to local7 to log to instead. The option value should be an integer

    # value, e.g. "log_facility 5" to use local5.

    #log_facility


    # If set to true, add a timestamp value to each log message.

    #log_timestamp true


    # Set the format of the log timestamp. If left unset, this is the number of

    # seconds since the Unix epoch.

    # This is a free text string which will be passed to the strftime function.
    To

    # get an ISO 8601 datetime, for example:

    # log_timestamp_format %Y-%m-%dT%H:%M:%S

    #log_timestamp_format


    # Change the websockets logging level. This is a global option, it is not

    # possible to set per listener. This is an integer that is interpreted by

    # libwebsockets as a bit mask for its lws_log_levels enum. See the

    # libwebsockets documentation for more details. "log_type websockets" must
    also

    # be enabled.

    #websockets_log_level 0



    # =================================================================

    # Security

    # =================================================================


    # If set, only clients that have a matching prefix on their

    # clientid will be allowed to connect to the broker. By default,

    # all clients may connect.

    # For example, setting "secure-" here would mean a client "secure-

    # client" could connect but another with clientid "mqtt" couldn't.

    #clientid_prefixes


    # Boolean value that determines whether clients that connect

    # without providing a username are allowed to connect. If set to

    # false then a password file should be created (see the

    # password_file option) to control authenticated client access.

    #

    # Defaults to true if no other security options are set. If `password_file`
    or

    # `psk_file` is set, or if an authentication plugin is loaded which
    implements

    # username/password or TLS-PSK checks, then `allow_anonymous` defaults to

    # false.

    #

    allow_anonymous true


    # -----------------------------------------------------------------

    # Default authentication and topic access control

    # -----------------------------------------------------------------


    # Control access to the broker using a password file. This file can be

    # generated using the mosquitto_passwd utility. If TLS support is not
    compiled

    # into mosquitto (it is recommended that TLS support should be included)
    then

    # plain text passwords are used, in which case the file should be a text
    file

    # with lines in the format:

    # username:password

    # The password (and colon) may be omitted if desired, although this

    # offers very little in the way of security.

    #

    # See the TLS client require_certificate and use_identity_as_username
    options

    # for alternative authentication options. If an auth_plugin is used as well
    as

    # password_file, the auth_plugin check will be made first.

    #password_file


    # Access may also be controlled using a pre-shared-key file. This requires

    # TLS-PSK support and a listener configured to use it. The file should be
    text

    # lines in the format:

    # identity:key

    # The key should be in hexadecimal format without a leading "0x".

    # If an auth_plugin is used as well, the auth_plugin check will be made
    first.

    #psk_file


    # Control access to topics on the broker using an access control list

    # file. If this parameter is defined then only the topics listed will

    # have access.

    # If the first character of a line of the ACL file is a # it is treated as a

    # comment.

    # Topic access is added with lines of the format:

    #

    # topic [read|write|readwrite] <topic>

    #

    # The access type is controlled using "read", "write" or "readwrite". This

    # parameter is optional (unless <topic> contains a space character) - if not

    # given then the access is read/write.  <topic> can contain the + or #

    # wildcards as in subscriptions.

    #

    # The first set of topics are applied to anonymous clients, assuming

    # allow_anonymous is true. User specific topic ACLs are added after a

    # user line as follows:

    #

    # user <username>

    #

    # The username referred to here is the same as in password_file. It is

    # not the clientid.

    #

    #

    # If is also possible to define ACLs based on pattern substitution within
    the

    # topic. The patterns available for substition are:

    #

    # %c to match the client id of the client

    # %u to match the username of the client

    #

    # The substitution pattern must be the only text for that level of
    hierarchy.

    #

    # The form is the same as for the topic keyword, but using pattern as the

    # keyword.

    # Pattern ACLs apply to all users even if the "user" keyword has previously

    # been given.

    #

    # If using bridges with usernames and ACLs, connection messages can be
    allowed

    # with the following pattern:

    # pattern write $SYS/broker/connection/%c/state

    #

    # pattern [read|write|readwrite] <topic>

    #

    # Example:

    #

    # pattern write sensor/%u/data

    #

    # If an auth_plugin is used as well as acl_file, the auth_plugin check will
    be

    # made first.

    #acl_file


    # -----------------------------------------------------------------

    # External authentication and topic access plugin options

    # -----------------------------------------------------------------


    # External authentication and access control can be supported with the

    # auth_plugin option. This is a path to a loadable plugin. See also the

    # auth_opt_* options described below.

    #

    # The auth_plugin option can be specified multiple times to load multiple

    # plugins. The plugins will be processed in the order that they are
    specified

    # here. If the auth_plugin option is specified alongside either of

    # password_file or acl_file then the plugin checks will be made first.

    #

    #auth_plugin


    # If the auth_plugin option above is used, define options to pass to the

    # plugin here as described by the plugin instructions. All options named

    # using the format auth_opt_* will be passed to the plugin, for example:

    #

    # auth_opt_db_host

    # auth_opt_db_port

    # auth_opt_db_username

    # auth_opt_db_password



    # =================================================================

    # Bridges

    # =================================================================


    # A bridge is a way of connecting multiple MQTT brokers together.

    # Create a new bridge using the "connection" option as described below. Set

    # options for the bridges using the remaining parameters. You must specify
    the

    # address and at least one topic to subscribe to.

    #

    # Each connection must have a unique name.

    #

    # The address line may have multiple host address and ports specified. See

    # below in the round_robin description for more details on bridge behaviour
    if

    # multiple addresses are used. Note that if you use an IPv6 address, then
    you

    # are required to specify a port.

    #

    # The direction that the topic will be shared can be chosen by

    # specifying out, in or both, where the default value is out.

    # The QoS level of the bridged communication can be specified with the next

    # topic option. The default QoS level is 0, to change the QoS the topic

    # direction must also be given.

    #

    # The local and remote prefix options allow a topic to be remapped when it
    is

    # bridged to/from the remote broker. This provides the ability to place a
    topic

    # tree in an appropriate location.

    #

    # For more details see the mosquitto.conf man page.

    #

    # Multiple topics can be specified per connection, but be careful

    # not to create any loops.

    #

    # If you are using bridges with cleansession set to false (the default),
    then

    # you may get unexpected behaviour from incoming topics if you change what

    # topics you are subscribing to. This is because the remote broker keeps the

    # subscription for the old topic. If you have this problem, connect your
    bridge

    # with cleansession set to true, then reconnect with cleansession set to
    false

    # as normal.

    #connection <name>

    #address <host>[:<port>] [<host>[:<port>]]

    #topic <topic> [[[out | in | both] qos-level] local-prefix remote-prefix]



    # If a bridge has topics that have "out" direction, the default behaviour is
    to

    # send an unsubscribe request to the remote broker on that topic. This means

    # that changing a topic direction from "in" to "out" will not keep receiving

    # incoming messages. Sending these unsubscribe requests is not always

    # desirable, setting bridge_attempt_unsubscribe to false will disable
    sending

    # the unsubscribe request.

    #bridge_attempt_unsubscribe true


    # Set the version of the MQTT protocol to use with for this bridge. Can be
    one

    # of mqttv311 or mqttv11. Defaults to mqttv311.

    #bridge_protocol_version mqttv311


    # Set the clean session variable for this bridge.

    # When set to true, when the bridge disconnects for any reason, all

    # messages and subscriptions will be cleaned up on the remote

    # broker. Note that with cleansession set to true, there may be a

    # significant amount of retained messages sent when the bridge

    # reconnects after losing its connection.

    # When set to false, the subscriptions and messages are kept on the

    # remote broker, and delivered when the bridge reconnects.

    #cleansession false


    # Set the amount of time a bridge using the lazy start type must be idle
    before

    # it will be stopped. Defaults to 60 seconds.

    #idle_timeout 60


    # Set the keepalive interval for this bridge connection, in

    # seconds.

    #keepalive_interval 60


    # Set the clientid to use on the local broker. If not defined, this defaults
    to

    # 'local.<clientid>'. If you are bridging a broker to itself, it is
    important

    # that local_clientid and clientid do not match.

    #local_clientid


    # If set to true, publish notification messages to the local and remote
    brokers

    # giving information about the state of the bridge connection. Retained

    # messages are published to the topic
    $SYS/broker/connection/<clientid>/state

    # unless the notification_topic option is used.

    # If the message is 1 then the connection is active, or 0 if the connection
    has

    # failed.

    # This uses the last will and testament feature.

    #notifications true


    # Choose the topic on which notification messages for this bridge are

    # published. If not set, messages are published on the topic

    # $SYS/broker/connection/<clientid>/state

    #notification_topic


    # Set the client id to use on the remote end of this bridge connection. If
    not

    # defined, this defaults to 'name.hostname' where name is the connection
    name

    # and hostname is the hostname of this computer.

    # This replaces the old "clientid" option to avoid confusion. "clientid"

    # remains valid for the time being.

    #remote_clientid


    # Set the password to use when connecting to a broker that requires

    # authentication. This option is only used if remote_username is also set.

    # This replaces the old "password" option to avoid confusion. "password"

    # remains valid for the time being.

    #remote_password


    # Set the username to use when connecting to a broker that requires

    # authentication.

    # This replaces the old "username" option to avoid confusion. "username"

    # remains valid for the time being.

    #remote_username


    # Set the amount of time a bridge using the automatic start type will wait

    # until attempting to reconnect.

    # This option can be configured to use a constant delay time in seconds, or
    to

    # use a backoff mechanism based on "Decorrelated Jitter", which adds a
    degree

    # of randomness to when the restart occurs.

    #

    # Set a constant timeout of 20 seconds:

    # restart_timeout 20

    #

    # Set backoff with a base (start value) of 10 seconds and a cap (upper
    limit) of

    # 60 seconds:

    # restart_timeout 10 30

    #

    # Defaults to jitter with a base of 5 and cap of 30

    #restart_timeout 5 30


    # If the bridge has more than one address given in the address/addresses

    # configuration, the round_robin option defines the behaviour of the bridge
    on

    # a failure of the bridge connection. If round_robin is false, the default

    # value, then the first address is treated as the main bridge connection. If

    # the connection fails, the other secondary addresses will be attempted in

    # turn. Whilst connected to a secondary bridge, the bridge will periodically

    # attempt to reconnect to the main bridge until successful.

    # If round_robin is true, then all addresses are treated as equals. If a

    # connection fails, the next address will be tried and if successful will

    # remain connected until it fails

    #round_robin false


    # Set the start type of the bridge. This controls how the bridge starts and

    # can be one of three types: automatic, lazy and once. Note that RSMB
    provides

    # a fourth start type "manual" which isn't currently supported by mosquitto.

    #

    # "automatic" is the default start type and means that the bridge connection

    # will be started automatically when the broker starts and also restarted

    # after a short delay (30 seconds) if the connection fails.

    #

    # Bridges using the "lazy" start type will be started automatically when the

    # number of queued messages exceeds the number set with the "threshold"

    # parameter. It will be stopped automatically after the time set by the

    # "idle_timeout" parameter. Use this start type if you wish the connection
    to

    # only be active when it is needed.

    #

    # A bridge using the "once" start type will be started automatically when
    the

    # broker starts but will not be restarted if the connection fails.

    #start_type automatic


    # Set the number of messages that need to be queued for a bridge with lazy

    # start type to be restarted. Defaults to 10 messages.

    # Must be less than max_queued_messages.

    #threshold 10


    # If try_private is set to true, the bridge will attempt to indicate to the

    # remote broker that it is a bridge not an ordinary client. If successful,
    this

    # means that loop detection will be more effective and that retained
    messages

    # will be propagated correctly. Not all brokers support this feature so it
    may

    # be necessary to set try_private to false if your bridge does not connect

    # properly.

    #try_private true


    # -----------------------------------------------------------------

    # Certificate based SSL/TLS support

    # -----------------------------------------------------------------

    # Either bridge_cafile or bridge_capath must be defined to enable TLS
    support

    # for this bridge.

    # bridge_cafile defines the path to a file containing the

    # Certificate Authority certificates that have signed the remote broker

    # certificate.

    # bridge_capath defines a directory that will be searched for files
    containing

    # the CA certificates. For bridge_capath to work correctly, the certificate

    # files must have ".crt" as the file ending and you must run "openssl rehash

    # <path to capath>" each time you add/remove a certificate.

    #bridge_cafile

    #bridge_capath



    # If the remote broker has more than one protocol available on its port,
    e.g.

    # MQTT and WebSockets, then use bridge_alpn to configure which protocol is

    # requested. Note that WebSockets support for bridges is not yet available.

    #bridge_alpn


    # When using certificate based encryption, bridge_insecure disables

    # verification of the server hostname in the server certificate. This can be

    # useful when testing initial server configurations, but makes it possible
    for

    # a malicious third party to impersonate your server through DNS spoofing,
    for

    # example. Use this option in testing only. If you need to resort to using
    this

    # option in a production environment, your setup is at fault and there is no

    # point using encryption.

    #bridge_insecure false


    # Path to the PEM encoded client certificate, if required by the remote
    broker.

    #bridge_certfile


    # Path to the PEM encoded client private key, if required by the remote
    broker.

    #bridge_keyfile


    # -----------------------------------------------------------------

    # PSK based SSL/TLS support

    # -----------------------------------------------------------------

    # Pre-shared-key encryption provides an alternative to certificate based

    # encryption. A bridge can be configured to use PSK with the bridge_identity

    # and bridge_psk options. These are the client PSK identity, and
    pre-shared-key

    # in hexadecimal format with no "0x". Only one of certificate and PSK based

    # encryption can be used on one

    # bridge at once.

    #bridge_identity

    #bridge_psk



    # =================================================================

    # External config files

    # =================================================================


    # External configuration files may be included by using the

    # include_dir option. This defines a directory that will be searched

    # for config files. All files that end in '.conf' will be loaded as

    # a configuration file. It is best to have this as the last option

    # in the main file. This option will only be processed from the main

    # configuration file. The directory specified must not contain the

    # main configuration file.

    # Files within include_dir will be loaded sorted in case-sensitive

    # alphabetical order, with capital letters ordered first. If this option is

    # given multiple times, all of the files from the first instance will be

    # processed before the next instance. See the man page for examples.

    #include_dir
---
apiVersion: v1
kind: Service
metadata:
  name: device-dashboard
  namespace: edge-system
spec:
  type: NodePort
  selector:
    app: device-dashboard
  ports:
    - port: 4000
      nodePort: 4000
      name: port-40000
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: device-dashboard
  namespace: edge-system
  labels:
    app: device-dashboard
spec:
  replicas: 1
  selector:
    matchLabels:
      app: device-dashboard
  template:
    metadata:
      name: device-dashboard
      labels:
        app: device-dashboard
    spec:
      volumes:
        - name: config
          configMap:
            name: device-dashboard
        - name: device-dashboard-volume
          persistentVolumeClaim:
            claimName: device-dashboard-claim
      containers:
        - name: device-dashboard
          image: edgego/device-dashboard:v2.3.8
          imagePullPolicy: Always
          ports:
            - containerPort: 4000
          env:
            - name: MY_POD_NAMESPACE
              valueFrom:
                fieldRef:
                  apiVersion: v1
                  fieldPath: metadata.namespace
            - name: EDGEX_SECURITY_SECRET_STORE
              value: "false"     
          volumeMounts:
            - name: device-dashboard-volume
              mountPath: /data
            - name: config
              mountPath: /res
          readinessProbe:
            tcpSocket:
              port: 4000
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            tcpSocket:
              port: 4000
            initialDelaySeconds: 15
            periodSeconds: 20
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: edge-redis-ha
  namespace: edge-system
  labels:
    heritage: Helm
    release: edge
    chart: redis-ha-4.4.6
    app: edge-redis-ha
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: edge-redis-ha-configmap
  namespace: edge-system
  labels:
    heritage: Helm
    release: edge
    chart: redis-ha-4.4.6
    app: edge-redis-ha
data:
  redis.conf: |
    dir "/data"
    port 6379
    maxmemory 0
    maxmemory-policy volatile-lru
    min-replicas-max-lag 5
    min-replicas-to-write 1
    rdbchecksum yes
    rdbcompression yes
    repl-diskless-sync yes
    save 900 1

  sentinel.conf: |
    dir "/data"
        sentinel down-after-milliseconds mymaster 10000
        sentinel failover-timeout mymaster 180000
        maxclients 10000
        sentinel parallel-syncs mymaster 5

  init.sh: |
    HOSTNAME="$(hostname)"
    INDEX="${HOSTNAME##*-}"
    MASTER="$(redis-cli -h edge-redis-ha -p 26379 sentinel get-master-addr-by-name mymaster | grep -E '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}')"
    MASTER_GROUP="mymaster"
    QUORUM="2"
    REDIS_CONF=/data/conf/redis.conf
    REDIS_PORT=6379
    SENTINEL_CONF=/data/conf/sentinel.conf
    SENTINEL_PORT=26379
    SERVICE=edge-redis-ha
    set -eu

    sentinel_update() {
        echo "Updating sentinel config with master $MASTER"
        eval MY_SENTINEL_ID="\${SENTINEL_ID_$INDEX}"
        sed -i "1s/^/sentinel myid $MY_SENTINEL_ID\\n/" "$SENTINEL_CONF"
        sed -i "2s/^/sentinel monitor $MASTER_GROUP $1 $REDIS_PORT $QUORUM \\n/" "$SENTINEL_CONF"
        echo "sentinel announce-ip $ANNOUNCE_IP" >> $SENTINEL_CONF
        echo "sentinel announce-port $SENTINEL_PORT" >> $SENTINEL_CONF
    }

    redis_update() {
        echo "Updating redis config"
        echo "slaveof $1 $REDIS_PORT" >> "$REDIS_CONF"
        echo "slave-announce-ip $ANNOUNCE_IP" >> $REDIS_CONF
        echo "slave-announce-port $REDIS_PORT" >> $REDIS_CONF
    }

    copy_config() {
        cp /readonly-config/redis.conf "$REDIS_CONF"
        cp /readonly-config/sentinel.conf "$SENTINEL_CONF"
    }

    setup_defaults() {
        echo "Setting up defaults"
        if [ "$INDEX" = "0" ]; then
            echo "Setting this pod as the default master"
            redis_update "$ANNOUNCE_IP"
            sentinel_update "$ANNOUNCE_IP"
            sed -i "s/^.*slaveof.*//" "$REDIS_CONF"
        else
            DEFAULT_MASTER="$(getent hosts "$SERVICE-announce-0" | awk '{ print $1 }')"
            if [ -z "$DEFAULT_MASTER" ]; then
                echo "Unable to resolve host"
                exit 1
            fi
            echo "Setting default slave config.."
            redis_update "$DEFAULT_MASTER"
            sentinel_update "$DEFAULT_MASTER"
        fi
    }

    find_master() {
        echo "Attempting to find master"
        if [ "$(redis-cli -h "$MASTER" ping)" != "PONG" ]; then
           echo "Can't ping master, attempting to force failover"
           if redis-cli -h "$SERVICE" -p "$SENTINEL_PORT" sentinel failover "$MASTER_GROUP" | grep -q 'NOGOODSLAVE' ; then
               setup_defaults
               return 0
           fi
           sleep 10
           MASTER="$(redis-cli -h $SERVICE -p $SENTINEL_PORT sentinel get-master-addr-by-name $MASTER_GROUP | grep -E '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}')"
           if [ "$MASTER" ]; then
               sentinel_update "$MASTER"
               redis_update "$MASTER"
           else
              echo "Could not failover, exiting..."
              exit 1
           fi
        else
            echo "Found reachable master, updating config"
            sentinel_update "$MASTER"
            redis_update "$MASTER"
        fi
    }

    mkdir -p /data/conf/

    echo "Initializing config.."
    copy_config

    ANNOUNCE_IP=$(getent hosts "$SERVICE-announce-$INDEX" | awk '{ print $1 }')
    if [ -z "$ANNOUNCE_IP" ]; then
        "Could not resolve the announce ip for this pod"
        exit 1
    elif [ "$MASTER" ]; then
        find_master
    else
        setup_defaults
    fi

    if [ "${AUTH:-}" ]; then
        echo "Setting auth values"
        ESCAPED_AUTH=$(echo "$AUTH" | sed -e 's/[\/&]/\\&/g');
        sed -i "s/replace-default-auth/${ESCAPED_AUTH}/" "$REDIS_CONF" "$SENTINEL_CONF"
    fi

    echo "Ready..."

  haproxy_init.sh: |
    HAPROXY_CONF=/data/haproxy.cfg
    cp /readonly/haproxy.cfg "$HAPROXY_CONF"
    for loop in $(seq 1 10); do
      getent hosts edge-redis-ha-announce-0 && break
      echo "Waiting for service edge-redis-ha-announce-0 to be ready ($loop) ..." && sleep 1
    done
    ANNOUNCE_IP0=$(getent hosts "edge-redis-ha-announce-0" | awk '{ print $1 }')
    if [ -z "$ANNOUNCE_IP0" ]; then
      echo "Could not resolve the announce ip for edge-redis-ha-announce-0"
      exit 1
    fi
    sed -i "s/REPLACE_ANNOUNCE0/$ANNOUNCE_IP0/" "$HAPROXY_CONF"

    if [ "${AUTH:-}" ]; then
        echo "Setting auth values"
        ESCAPED_AUTH=$(echo "$AUTH" | sed -e 's/[\/&]/\\&/g');
        sed -i "s/REPLACE_AUTH_SECRET/${ESCAPED_AUTH}/" "$HAPROXY_CONF"
    fi
    for loop in $(seq 1 10); do
      getent hosts edge-redis-ha-announce-1 && break
      echo "Waiting for service edge-redis-ha-announce-1 to be ready ($loop) ..." && sleep 1
    done
    ANNOUNCE_IP1=$(getent hosts "edge-redis-ha-announce-1" | awk '{ print $1 }')
    if [ -z "$ANNOUNCE_IP1" ]; then
      echo "Could not resolve the announce ip for edge-redis-ha-announce-1"
      exit 1
    fi
    sed -i "s/REPLACE_ANNOUNCE1/$ANNOUNCE_IP1/" "$HAPROXY_CONF"

    if [ "${AUTH:-}" ]; then
        echo "Setting auth values"
        ESCAPED_AUTH=$(echo "$AUTH" | sed -e 's/[\/&]/\\&/g');
        sed -i "s/REPLACE_AUTH_SECRET/${ESCAPED_AUTH}/" "$HAPROXY_CONF"
    fi
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: edge-redis-ha
  namespace: edge-system
  labels:
    heritage: Helm
    release: edge
    chart: redis-ha-4.4.6
    app: edge-redis-ha
rules:
- apiGroups:
    - ""
  resources:
    - endpoints
  verbs:
    - get
---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: edge-redis-ha
  namespace: edge-system
  labels:
    heritage: Helm
    release: edge
    chart: redis-ha-4.4.6
    app: edge-redis-ha
subjects:
- kind: ServiceAccount
  name: edge-redis-ha
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: edge-redis-ha
---
apiVersion: v1
kind: Service
metadata:
  name: edge-redis-ha-announce-0
  namespace: edge-system
  labels:
    app: redis-ha
    heritage: "Helm"
    release: "edge"
    chart: redis-ha-4.4.6
  annotations:
    service.alpha.kubernetes.io/tolerate-unready-endpoints: "true"
spec:
  publishNotReadyAddresses: true
  type: ClusterIP
  ports:
  - name: server
    port: 6379
    protocol: TCP
    targetPort: redis
  - name: sentinel
    port: 26379
    protocol: TCP
    targetPort: sentinel
  selector:
    release: edge
    app: redis-ha
    "statefulset.kubernetes.io/pod-name": edge-redis-ha-server-0
---
apiVersion: v1
kind: Service
metadata:
  name: edge-redis-ha-announce-1
  namespace: edge-system
  labels:
    app: redis-ha
    heritage: "Helm"
    release: "edge"
    chart: redis-ha-4.4.6
  annotations:
    service.alpha.kubernetes.io/tolerate-unready-endpoints: "true"
spec:
  publishNotReadyAddresses: true
  type: ClusterIP
  ports:
  - name: server
    port: 6379
    protocol: TCP
    targetPort: redis
  - name: sentinel
    port: 26379
    protocol: TCP
    targetPort: sentinel
  selector:
    release: edge
    app: redis-ha
    "statefulset.kubernetes.io/pod-name": edge-redis-ha-server-1
---

apiVersion: v1
kind: Service
metadata:
  name: edge-redis-ha
  namespace: edge-system
  labels:
    app: redis-ha
    heritage: "Helm"
    release: "edge"
    chart: redis-ha-4.4.6
  annotations:
spec:
  type: ClusterIP
  clusterIP: None
  ports:
  - name: server
    port: 6379
    protocol: TCP
    targetPort: redis
  - name: sentinel
    port: 26379
    protocol: TCP
    targetPort: sentinel
  selector:
    release: edge
    app: redis-ha
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: edge-redis-ha-server
  namespace: edge-system
  labels:
    edge-redis-ha: replica
    app: redis-ha
    heritage: "Helm"
    release: "edge"
    chart: redis-ha-4.4.6
spec:
  selector:
    matchLabels:
      release: edge
      app: redis-ha
  serviceName: edge-redis-ha
  replicas: 2
  podManagementPolicy: OrderedReady
  updateStrategy:
    type: RollingUpdate
  template:
    metadata:
      annotations:
        checksum/init-config: fabfc20ab0ee42dda389e4ff5d157400ca2329c1c6d511e99c15f6dbefaf4e93
      labels:
        release: edge
        app: redis-ha
        edge-redis-ha: replica
    spec:
    #  affinity:
    #    podAntiAffinity:
    #      requiredDuringSchedulingIgnoredDuringExecution:
    #        - labelSelector:
    #            matchLabels:
    #              app: redis-ha
    #              release: edge
    #              edge-redis-ha: replica
    #          topologyKey: kubernetes.io/hostname
    #      preferredDuringSchedulingIgnoredDuringExecution:
    #        - weight: 100
    #          podAffinityTerm:
    #            labelSelector:
    #              matchLabels:
    #                app:  redis-ha
    #                release: edge
    #                edge-redis-ha: replica
    #            topologyKey: failure-domain.beta.kubernetes.io/zone
      securityContext:
        fsGroup: 1000
        runAsNonRoot: true
        runAsUser: 1000
      serviceAccountName: edge-redis-ha
      initContainers:
      - name: config-init
        image: edgego/redis:6.2.13
        imagePullPolicy: IfNotPresent
        resources:
          {}
        command:
        - sh
        args:
        - /readonly-config/init.sh
        env:
        - name: SENTINEL_ID_0
          value: 1eb9e186ee14b693bd731e9f55c4cb33eff44f03

        - name: SENTINEL_ID_1
          value: 13fdae7286bc203d3acc5e596d8bfc63f259692c

        volumeMounts:
        - name: config
          mountPath: /readonly-config
          readOnly: true
        - name: data
          mountPath: /data
      containers:
      - name: redis
        image: edgego/redis:6.2.13
        imagePullPolicy: IfNotPresent
        command:
        - redis-server
        args:
        - /data/conf/redis.conf
        livenessProbe:
          tcpSocket:
            port: 6379
          initialDelaySeconds: 15
        resources:
          {}
        ports:
        - name: redis
          containerPort: 6379
        volumeMounts:
        - mountPath: /data
          name: data
      - name: sentinel
        image: edgego/redis:6.2.13
        imagePullPolicy: IfNotPresent
        command:
          - redis-sentinel
        args:
          - /data/conf/sentinel.conf
        livenessProbe:
          tcpSocket:
            port: 26379
          initialDelaySeconds: 15
        resources:
          {}
        ports:
          - name: sentinel
            containerPort: 26379
        volumeMounts:
        - mountPath: /data
          name: data
      volumes:
      - name: config
        configMap:
          name: edge-redis-ha-configmap
  volumeClaimTemplates:
  - metadata:
      name: data
      annotations:
    spec:
      accessModes:
        - "ReadWriteOnce"
      resources:
        requests:
          storage: "10Gi"
      storageClassName: local-path    
---
apiVersion: v1
kind: Pod
metadata:
  name: edge-redis-ha-service-test
  namespace: edge-system
  labels:
    app: redis-ha
    heritage: "Helm"
    release: "edge"
    chart: redis-ha-4.4.6
  annotations:
    "helm.sh/hook": test-success
spec:
  containers:
  - name: "edge-service-test"
    image: edgego/redis:6.2.13
    command:
      - sh
      - -c
      - redis-cli -h edge-redis-ha -p 6379 info server
  restartPolicy: Never
---
apiVersion: v1
kind: Service
metadata:
  name: edge-support-notifications
  namespace: edge-system
spec:
  type: NodePort
  selector:
    app: edge-support-notifications
  ports:
    - port: 59860
      nodePort: 59860
      name: port-59860
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: edge-support-notifications
  namespace: edge-system
  labels:
    app: edge-support-notifications
spec:
  replicas: 1
  selector:
    matchLabels:
      app: edge-support-notifications
  template:
    metadata:
      name: edge-support-notifications
      labels:
        app: edge-support-notifications
    spec:
      volumes:
        - name: config
          configMap:
            name: edge-support-notifications
      containers:
        - name: edge-support-notifications
          image: edgego/support-notifications:v2.3.0
          command:
            - /support-notifications
            - '--confdir'
            - /res
          imagePullPolicy: Always
          ports:
            - containerPort: 59860
          env:
             - name: EDGEX_SECURITY_SECRET_STORE
               value: "false"
          volumeMounts:
            - name: config
              mountPath: /res
          readinessProbe:
            httpGet:
              path: /api/v2/ping
              port: 59860
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /api/v2/ping
              port: 59860
            initialDelaySeconds: 15
            periodSeconds: 20
---
apiVersion: v1
kind: Service
metadata:
  name: edge-core-data
  namespace: edge-system
spec:
  type: NodePort
  selector:
    app: edge-core-data
  ports:
    - port: 59880
      nodePort: 59880
      name: port-59880
    - port: 5563
      name: port-5563
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: edge-core-data
  namespace: edge-system
  labels:
    app: edge-core-data
spec:
  replicas: 1
  selector:
    matchLabels:
      app: edge-core-data
  template:
    metadata:
      name: edge-core-data
      labels:
        app: edge-core-data
    spec:
      volumes:
        - name: config
          configMap:
            name: edge-core-data
      containers:
        - name: edge-core-data
          image: edgego/core-data:v2.3.0
          command:
            - /core-data
            - '--confdir'
            - /res
          imagePullPolicy: Always
          env:
            - name: EDGEX_SECURITY_SECRET_STORE
              value: "false"
          volumeMounts:
           - name: config
             mountPath: /res
          ports:
            - containerPort: 59880
            - containerPort: 5563
          readinessProbe:
            httpGet:
              path: /api/v2/ping
              port: 59880
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /api/v2/ping
              port: 59880
            initialDelaySeconds: 15
            periodSeconds: 20
---
apiVersion: v1
kind: Service
metadata:
  name: edge-core-metadata
  namespace: edge-system
spec:
  type: NodePort
  selector:
    app: edge-core-metadata
  ports:
    - port: 59881
      nodePort: 59881
      name: port-59881
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: edge-core-metadata
  namespace: edge-system
  labels:
    app: edge-core-metadata
spec:
  replicas: 1
  selector:
    matchLabels:
      app: edge-core-metadata
  template:
    metadata:
      name: edge-core-metadata
      labels:
        app: edge-core-metadata
    spec:
      volumes:
        - name: config
          configMap:
            name: edge-core-metadata
        - name: uom
          configMap:
            name: edge-metadata-uom
      containers:
        - name: edge-core-metadata
          image: edgego/core-metadata:v2.3.0
          command:
            - /core-metadata
            - '--confdir'
            - /res
          env:
            - name: EDGEX_SECURITY_SECRET_STORE
              value: "false"
          volumeMounts:
             - name: config
               mountPath: /res
             - name: uom
               mountPath: /res/uom
          ports:
            - containerPort: 59881
          readinessProbe:
            httpGet:
              path: /api/v2/ping
              port: 59881
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /api/v2/ping
              port: 59881
            initialDelaySeconds: 15
            periodSeconds: 20
---
apiVersion: v1
kind: Service
metadata:
  name: edge-core-command
  namespace: edge-system
spec:
  type: NodePort
  selector:
    app: edge-core-command
  ports:
    - port: 59882
      nodePort: 59882
      name: port-59882
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: edge-core-command
  namespace: edge-system
  labels:
    app: edge-core-command
spec:
  replicas: 1
  selector:
    matchLabels:
      app: edge-core-command
  template:
    metadata:
      name: edge-core-command
      labels:
        app: edge-core-command
    spec:
      volumes:
        - name: config
          configMap:
            name: edge-core-command
      containers:
        - name: edge-core-command
          image: edgego/core-command:v2.3.0
          command:
            - /core-command
            - '--confdir'
            - /res
          imagePullPolicy: Always
          env:
            - name: EDGEX_SECURITY_SECRET_STORE
              value: "false"
          volumeMounts:
            - name: config
              mountPath: /res
          ports:
            - containerPort: 59882
          readinessProbe:
            httpGet:
              path: /api/v2/ping
              port: 59882
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /api/v2/ping
              port: 59882
            initialDelaySeconds: 15
            periodSeconds: 20
---
apiVersion: v1
kind: Service
metadata:
  name: edge-support-scheduler
  namespace: edge-system
spec:
  type: NodePort
  selector:
    app: edge-support-scheduler
  ports:
    - port: 59861
      nodePort: 59861
      name: port-59861
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: edge-support-scheduler
  namespace: edge-system
  labels:
    app: edge-support-scheduler
spec:
  replicas: 1
  selector:
    matchLabels:
      app: edge-support-scheduler
  template:
    metadata:
      name: edge-support-scheduler
      labels:
        app: edge-support-scheduler
    spec:
      volumes:
        - name: config
          configMap:
            name: edge-support-scheduler
      containers:
        - name: edge-support-scheduler
          image: edgego/support-scheduler:v2.3.0
          command:
            - /support-scheduler
            - '--confdir'
            - /res
          imagePullPolicy: Always
          env:
            - name: EDGEX_SECURITY_SECRET_STORE
              value: "false"
          volumeMounts:
            - name: config
              mountPath: /res
          ports:
            - containerPort: 59861
          readinessProbe:
            httpGet:
              path: /api/v2/ping
              port: 59861
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /api/v2/ping
              port: 59861
            initialDelaySeconds: 15
            periodSeconds: 20
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: kuiper-conn
  namespace: edge-system
data:
  connection.yaml: |-
    edgex:
       mqttMsgBus: #connection key
          protocol: tcp
          server: edge-mqtt-broker
          port: 1883
          type: mqtt
    mqtt:
      localConnection: #connection key
        servers: [tcp://127.0.0.1:1883]
        username: ekuiper
        password: password
        #certificationPath: /var/kuiper/xyz-certificate.pem
        #privateKeyPath: /var/kuiper/xyz-private.pem.key
        #rootCaPath: /var/kuiper/xyz-rootca.pem
        #insecureSkipVerify: false
        #protocolVersion: 3
        clientid: ekuiper
      cloudConnection: #connection key
        servers: ["tcp://broker.emqx.io:1883"]
        username: user1
        password: password
        #certificationPath: /var/kuiper/xyz-certificate.pem
        #privateKeyPath: /var/kuiper/xyz-private.pem.ke
        #rootCaPath: /var/kuiper/xyz-rootca.pem
        #insecureSkipVerify: false
        #protocolVersion: 3
    edgex:
       mqttMsgBus: #mqtt connection key
        protocol: tcp
        server: edge-mqtt-broker
        port: 1883
        type: mqtt
        #  Below is optional configurations settings for mqtt
        #  optional:
        #    ClientId: client1
        #    Username: user1
        #    Password: password
        #    Qos: 1
        #    KeepAlive: 5000
        #    Retained: true/false
        #    ConnectionPayload:
        #    CertFile:
        #    KeyFile:
        #    CertPEMBlock:
        #    KeyPEMBlock:
        #    SkipCertVerify: true/false
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: edge-kuiper-claim
  namespace: edge-system
spec:
  storageClassName: local-path
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 100M
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: kuiper-source
  namespace: edge-system
data:
  edgex.yaml: |
    default:
       messageType: request
       port: 1883
       protocol: tcp
       server: edge-mqtt-broker
       topic: edgex/events/device#
       type: mqtt
       optional:
         KeepAlive: 10
         Qos: 0
         Retained: false
         SkipCertVerify: false
    share_conf:
       connectionSelector: edgex.mqttMsgBus
       messageType: event
       port: 1883
       protocol: tcp
       server: 192.168.1.244
       topic: events
       type: mqtt
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: kuiper-conf
  namespace: edge-system
data:
  kuiper.yaml: >-
    basic:
      # true|false, with debug level, it prints more debug info
      debug: true
      # true|false, if it's set to true, then the log will be print to console
      consoleLog: true
      # true|false, if it's set to true, then the log will be print to log file
      fileLog: true
      # How many hours to split the file
      rotateTime: 24
      # Maximum file storage hours
      maxAge: 72
      # CLI ip
      ip: 0.0.0.0
      # CLI port
      port: 20498
      # REST service ip
      restIp: 0.0.0.0
      # REST service port
      restPort: 59720
      # true|false, when true, will check the RSA jwt token for rest api
      authentication: false
      #  restTls:
      #    certfile: /var/https-server.crt
      #    keyfile: /var/https-server.key
      # Prometheus settings
      prometheus: false
      prometheusPort: 20499
      # The URL where hosts all of pre-build plugins. By default it's at packages.emqx.net
      pluginHosts: https://packages.emqx.net
      # Whether to ignore case in SQL processing. Note that, the name of customized function by plugins are case-sensitive.
      ignoreCase: true

    # The default options for all rules. Each rule can override this setting by
    defining its own option

    rule:
      # The qos of the rule. The values can be 0: At most once; 1: At least once; 2: Exactly once
      # If qos is bigger than 0, the checkpoint mechanism will launch to save states so that they can be
      # restored for unintended interrupt or planned restart of the rule. The performance may be affected
      # to enable the checkpoint mechanism
      qos: 0
      # The interval in millisecond to run the checkpoint mechanism.
      checkpointInterval: 300000
      # Whether to send errors to sinks
      sendError: true

    sink:
      # The cache persistence threshold size. If the message in sink cache is larger than 10, then it triggers persistence. If you find
      # the remote system is slow to response, or sink throughput is small, then it's recommend to increase below 2 configurations.
      # More memory is required with the increase of below 2 configurations.
      # If the message count reaches below value, then it triggers persistence.
      cacheThreshold: 10
      # The message persistence is triggered by a ticker, and cacheTriggerCount is for using configure the count to trigger the persistence procedure
      # regardless if the message number reaches cacheThreshold or not. This is to prevent the data won't be saved as the cache never pass the threshold.
      cacheTriggerCount: 15

      # Control to disable cache or not. If it's set to true, then the cache will be disabled, otherwise, it will be enabled.
      disableCache: true

    store:
      #Type of store that will be used for keeping state of the application
      type: sqlite
      redis:
        host: edge-redis-ha-announce-0
        port: 6379
        password: kuiper
        #Timeout in ms
        timeout: 1000
      sqlite:
        #Sqlite file name, if left empty name of db will be sqliteKV.db
        name:

    # The settings for portable plugin

    portable:
      # The executable of python. Specify this if you have multiple python instances in your system
      # or other circumstance where the python executable cannot be successfully invoked through the default command.
      pythonBin: python

---
kind: Service
apiVersion: v1
metadata:
  name: edge-kuiper
  namespace: edge-system
spec:
  ports:
    - name: port-59720
      protocol: TCP
      port: 59720
      targetPort: 59720
      nodePort: 59720
    - name: port-20498
      protocol: TCP
      port: 20498
      targetPort: 20498
      nodePort: 24048
  selector:
    app: edge-kuiper
  clusterIP: 10.43.209.22
  clusterIPs:
    - 10.43.209.22
  type: NodePort
  sessionAffinity: None
  externalTrafficPolicy: Cluster
  ipFamilies:
    - IPv4
  ipFamilyPolicy: SingleStack
  internalTrafficPolicy: Cluster
---
kind: Deployment
apiVersion: apps/v1
metadata:
  name: edge-kuiper
  namespace: edge-system
spec:
  replicas: 1
  selector:
    matchLabels:
      app: edge-kuiper
  template:
    metadata:
      name: edge-kuiper
      creationTimestamp: null
      labels:
        app: edge-kuiper
    spec:
      volumes:
        - name: kuiper-source
          configMap:
            name: kuiper-source
            defaultMode: 420
        - name: kuiper-conf
          configMap:
            name: kuiper-conf
            defaultMode: 420
        - name: kuiper-conn
          configMap:
            name: kuiper-conn
            defaultMode: 420
        - name: kuiper-data
          persistentVolumeClaim:
            claimName: edge-kuiper-claim
      containers:
        - name: edge-kuiper
          image: edgego/ekuiper:v1.11.0
          ports:
            - containerPort: 59720
              protocol: TCP
            - containerPort: 20498
              protocol: TCP
          env:
            - name: EDGEX_SECURITY_SECRET_STORE
              value: 'false'
          resources: {}
          volumeMounts:
            - name: kuiper-data
              mountPath: /kuiper/data
            - name: kuiper-source
              mountPath: /kuiper/etc/sources/edgex.yaml
              subPath: edgex.yaml
            - name: kuiper-conf
              mountPath: /kuiper/etc/kuiper.yaml
              subPath: kuiper.yaml
            - name: kuiper-conn
              mountPath: /kuiper/etc/connections/connection.yaml
              subPath: connection.yaml
          livenessProbe:
            httpGet:
              path: /
              port: 59720
              scheme: HTTP
            initialDelaySeconds: 15
            timeoutSeconds: 1
            periodSeconds: 20
            successThreshold: 1
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /
              port: 59720
              scheme: HTTP
            initialDelaySeconds: 5
            timeoutSeconds: 1
            periodSeconds: 10
            successThreshold: 1
            failureThreshold: 3
          terminationMessagePath: /dev/termination-log
          terminationMessagePolicy: File
          imagePullPolicy: IfNotPresent
      restartPolicy: Always
      terminationGracePeriodSeconds: 30
      dnsPolicy: ClusterFirst
      securityContext:
        runAsUser: 0
      schedulerName: default-scheduler
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: app-service-configurable
  namespace: edge-system
data:
  configuration.toml: >
    [Writable]

    LogLevel = "DEBUG"


    [Writable.StoreAndForward]
      Enabled = false
      RetryInterval = "5m"
      MaxRetryCount = 10

      [Writable.Pipeline]
      ExecutionOrder = "SetResponseData"
        [Writable.Pipeline.Functions.SetResponseData]
          [Writable.Pipeline.Functions.SetResponseData.Parameters]
          ResponseContentType = ""
        [Writable.Pipeline.Functions.FilterByProfileName]
          [Writable.Pipeline.Functions.FilterByProfileName.Parameters]
          ProfileNames = ""
          FilterOut = "false"
        [Writable.Pipeline.Functions.FilterByDeviceName]
          [Writable.Pipeline.Functions.FilterByDeviceName.Parameters]
          DeviceNames = ""
          FilterOut = "false"
        [Writable.Pipeline.Functions.FilterBySourceName]
          [Writable.Pipeline.Functions.FilterBySourceName.Parameters]
          SourceNames = ""
          FilterOut = "false"
        [Writable.Pipeline.Functions.FilterByResourceName]
          [Writable.Pipeline.Functions.FilterByResourceName.Parameters]
          ResourceNames = ""
          FilterOut = "false"
      # InsecureSecrets are required for Redis is used for message bus
      [Writable.InsecureSecrets]
        [Writable.InsecureSecrets.DB]
        path = "redisdb"
          [Writable.InsecureSecrets.DB.Secrets]
          username = ""
          password = ""

    [Service]

    HealthCheckInterval = "10s"

    Host = "edge-app-rules-engine"

    Port = 59701

    ServerBindAddr = "0.0.0.0" # if blank, uses default Go behavior
    https://golang.org/pkg/net/#Listen

    StartupMsg = "app-rules-engine has Started"

    MaxResultCount = 0 # Not curently used by App Services.

    MaxRequestSize = 0 # Not curently used by App Services.

    RequestTimeout = "5s"


    [Registry]

    Host = "localhost"

    Port = 8500

    Type = "consul"


    # Database is require when Redis is used for message bus

    # Type is used as the secret name when getting credentials from the Secret
    Store

    [Database]

    Type = "redisdb"

    Host = "edge-redis-ha-announce-0"

    Port = 6379

    Timeout = "30s"


    # SecretStore is required when Store and Forward is enabled and running with
    security

    # so Database credentials can be pulled from Vault. Also now require when
    running with secure Consul

    # Note when running in docker from compose file set the following
    environment variables:

    #   - SecretStore_Host: edgex-vault

    [SecretStore]

    Type = 'vault'

    Host = 'localhost'

    Port = 8200

    Path = 'app-rules-engine/'

    Protocol = 'http'

    RootCaCertPath = ''

    ServerName = ''

    TokenFile = '/tmp/edgex/secrets/app-rules-engine/secrets-token.json'
      [SecretStore.Authentication]
      AuthType = 'X-Vault-Token'

    [Clients]
      # Used for version check on start-up
      [Clients.core-metadata]
      Protocol = 'http'
      Host = 'edge-core-metadata'
      Port = 59881


    [Trigger]

    Type="edgex-messagebus"
      [Trigger.EdgexMessageBus]
       Type = "mqtt"
        [Trigger.EdgexMessageBus.SubscribeHost]
          Host = "edge-mqtt-broker"
          Port = 1883
          Protocol = "tcp"
          SubscribeTopics="edgex/events/#"
        [Trigger.EdgexMessageBus.PublishHost]
          Host = "edge-mqtt-broker"
          Port = 1883
          Protocol = "tcp"
           PublishTopic="app-rules-events"
        [Trigger.EdgexMessageBus.Optional]
          authmode = 'usernamepassword'  # required for redis messagebus (secure or insecure).
          secretname = 'redisdb'
          # Default MQTT Specific options that need to be here to enable evnironment variable overrides of them
          # Client Identifiers
          ClientId ="app-rules-events"
          # Connection information
          Qos          =  "0" # Quality of Sevice values are 0 (At most once), 1 (At least once) or 2 (Exactly once)
          KeepAlive    =  "500" # Seconds (must be 2 or greater)
          Retained     = "false"
          AutoReconnect  = "true"
          ConnectTimeout = "5" # Seconds
          # TLS configuration - Only used if Cert/Key file or Cert/Key PEMblock are specified
          SkipCertVerify = "false"
---
apiVersion: v1
kind: Service
metadata:
  name: edge-app-rules-engine
  namespace: edge-system
spec:
  type: NodePort
  selector:
    app: edge-app-rules-engine
  ports:
    - port: 59701
      nodePort: 59701
      name: port-59701
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: edge-app-rules-engine
  namespace: edge-system
  labels:
    app: edge-app-rules-engine
spec:
  replicas: 1
  selector:
    matchLabels:
      app: edge-app-rules-engine
  template:
    metadata:
      name: edge-app-rules-engine
      labels:
        app: edge-app-rules-engine
    spec:
      volumes:
        - name: config
          configMap:
            name: app-service-configurable
      containers:
        - name: app-service-configurable
          image: edgego/app-service-configurable:v2.3.0
          command:
            - /app-service-configurable
            - '--confdir'
            - /res
            - '--skipVersionCheck'
          env:
            - name: EDGEX_SECURITY_SECRET_STORE
              value: "false"
          volumeMounts:
            - name: config
              mountPath: /res
          ports:
            - containerPort: 59701
          readinessProbe:
            httpGet:
              path: /api/v2/ping
              port: 59701
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /api/v2/ping
              port: 59701
            initialDelaySeconds: 15
            periodSeconds: 20
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: edge-mqtt-broker-claim
  namespace: edge-system
spec:
  storageClassName: local-path
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 100M
---
apiVersion: v1
kind: Service
metadata:
  name: edge-mqtt-broker
  namespace: edge-system
spec:
  selector:
    app: edge-mqtt-broker
  ports:
    - port: 1883
      name: port-1883
---
kind: Deployment
apiVersion: apps/v1
metadata:
  name: edge-mqtt-broker
  namespace: edge-system
  labels:
    app: edge-mqtt-broker
spec:
  replicas: 1
  selector:
    matchLabels:
      app: edge-mqtt-broker
  template:
    metadata:
      name: edge-mqtt-broker
      creationTimestamp: null
      labels:
        app: edge-mqtt-broker
    spec:
      volumes:
        - name: mqtt-volume
          persistentVolumeClaim:
            claimName: edge-mqtt-broker-claim
        - name: config
          configMap:
            name: mosquitto-config
            defaultMode: 420
      containers:
        - name: edge-mqtt-broker
          image: eclipse-mosquitto:1.6.15
          ports:
            - containerPort: 1883
              protocol: TCP
          volumeMounts:
            - name: mqtt-volume
              mountPath: /mqtt/config
            - name: mqtt-volume
              mountPath: /mqtt/data
            - name: config
              mountPath: /mosquitto/config
          livenessProbe:
            tcpSocket:
              port: 1883
            initialDelaySeconds: 15
            timeoutSeconds: 1
            periodSeconds: 20
            successThreshold: 1
            failureThreshold: 3
          readinessProbe:
            tcpSocket:
              port: 1883
            initialDelaySeconds: 5
            timeoutSeconds: 1
            periodSeconds: 10
            successThreshold: 1
            failureThreshold: 3
---
